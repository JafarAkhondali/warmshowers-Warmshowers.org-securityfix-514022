/*
 * jQuery Translate plugin
 *
 * Version: 1.0.1
 *  
 * Copyright (c) 2008 Balázs Endrész (balazs.endresz@gmail.com)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php) 
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 * 
 * This plugin uses the 'Google AJAX Language API' (http://code.google.com/apis/ajaxlanguage/)
 * You can read the terms of use at http://code.google.com/apis/ajaxlanguage/terms.html
 * 
 * The copyEvents plugin is needed for rebinding some element's event handlers:
 * http://plugins.jquery.com/project/copyEvents
 * 
 */

;(function($){

//translation core function:
function translate(t, from, to, callback, opt, p){
	//-------------set parameters------------
	p ? '' : p={}; p.start ? '' : p.start=0; p.l ? '' : p.l=t.length; p.tf ? '' : p.tf='';
	p.end=p.start*1+opt.limit; p.ts=t.substring(p.start,p.end); var tt='';
	typeof p.divs=='undefined' ? p.divs=0 : '';

	//----------break on end of sentence or tag----------
	var mymatch0=/<(?![^<]*>)/.exec(p.ts);
	if(mymatch0){//if broken tag present
		var mymatch1=/<(?![^<]*>)/.exec(p.ts);
		if(mymatch1){
			var lastdot=mymatch1.index;
			tt=p.ts.substring(0,lastdot);
		}else{
			tt=p.ts
		}
	}else{//if no broken tag
		var mymatch2=/>\s*$/.exec(p.ts);
		if(!mymatch2){//if doesn't end with '>'
			var mymatch3=/[\.\?\!;:](?![^\.\?\!;:]*[\.\?\!;:])/.exec(p.ts); 
			if(mymatch3){//if broken sentence present
				var lastdot=mymatch3.index+1;
				tt=p.ts.substring(0,lastdot);
			}else{
				tt=p.ts
			}
		}else{
			tt=p.ts
		}
	}
	
	p.start=p.start+tt.length;//set next start position
	
	//---------handle each callbacks as transl arrived----------
	var i=p.tf.length;
	while(p.tf.lastIndexOf('</div>',i)>-1){
		i=p.tf.lastIndexOf('</div>',i)-1;
		var subst=p.tf.substr(0,i);
		
		if(subst.match(/<div>/gi)){var divst=subst.match(/<div>/gi).length};
		if(subst.match(/<\/div>/gi)){var divcl=subst.match(/<\/div>/gi).length};
		if(typeof divst=='undefined'){divst=0;}
		if(typeof divcl=='undefined'){divcl=0;}

		if(divst==divcl+1){
			var divscompl=$(p.tf.substr(0,(i+7)));
			var divlen=divscompl.length
			if(p.divs!=divlen){//if new elements have been translated
				var each=divscompl.slice(p.divs,divlen)
				each.each(function(i){
					var k=p.divs+i;//generate index
					
					if(typeof p.finalarr=='undefined'){p.finalarr=[]}//populate an array from results
					var txteach=$.trim($(this).html());
					p.finalarr[k]=txteach;//create an array for complete callback
					if(from.length<2 && p.detlang){ from=p.detlang; }//set det.source lang, if wasn't set

					if(p.fn===true){//called from function
						opt.each(k, txteach, p.txtorig[k], from, to, opt, p.num)
					}else{//called from method
						callback(k, p.jqt[k], txteach, p.txtorig[k], from, to, opt, p.num);
					}
				})
				p.divs=divlen;
			}
			break;
		}
	}

	//---------translate one part of text-----------
	if(tt.length>0){
		google.language.translate(tt, from, to, function(result) {
			if(result.error){ 
				$.translate.w('google.language.translate error: '+result.error.code+' '+result.error.message); 
				return opt.error(result.error)
			}

			p.tf=p.tf+result.translation;
			p.detlang=result.detectedSourceLanguage;
			var mm=/[\.\?\!;:]$/.exec(p.tf); if(mm){p.tf=p.tf+' '}
			return translate(t, from, to, callback, opt, p);
		});
		p.num ? p.num=p.num*1+1 : p.num=1;
	}else{
	
	//------------translation complete------------
		if(!p.tf){ return; }

		p.tf=p.tf.replace(/\s*$/,'')
		if(from.length<2 && p.detlang){ from=p.detlang; }
		
		p.timeout ? clearTimeout(p.timeout) : '';

		if(p.fn===true){//called from function
			opt.complete(p.finalarr, p.txtorig, from, to, opt, p.num, p.jq)
		}else{
			opt.complete(p.jq, p.jqt, p.finalarr, p.txtorig, from, to, opt, p.num)
		}
	}
}


//
//  Translate method
//

$.fn.translate=function(){
		//-------------set arguments------------
		var from; var to; var opt={}; var a=arguments[0]; var b=arguments[1]; var c=arguments[2];
		if(typeof a=='undefined' || a.constructor==Object){return  $.translate.w("Destination language is not set");}
		if(!b && !c){from=''; to=a; }
		if(!c && b){
			if(b.constructor==Object){ from=''; to=a; opt=b;
			}else{ from=a; to=b; } }
		if(a.constructor==String && b && c){from=a; to=b; opt=c;}
		
		var options={
			walk: true,//true: executes the script on all child elements too, on complex pages this can take time
			//false: translates the given elements' html(), doesn't get their children, generates more requests
			returnAll: false,//true: returns all elements that have been translated, false: just the caller (this)
			replace: true,//replace original text an the page with the translation
			translate:true,//if set to false, elements won't be tranlated, you can return the processed elements
			limit: 500,//maximum number of characters sent by each google.language.translate() request
			rebind: true,//rebind event handlers for elements translated as html
			data: false,//store orig and translated text with $.data at 'translation.'+langCode.'+('html'|tagName)
			setLangAttr: false,//store destination language code in html lang attr
					//true: set the 'lang' attr; false:don't set any attr; a string: set that html attr
			subject: true,//if text is given, only that html attribute will be translated
			not: '',//jquery expr - elements to leave out (script will be omitted either this is set or not)
			comments: false,//true:translates comments too when an element's .html() is tranlated, 
							//false:removes the comments, when an element's .html() is tranlated
			altAndVal:true,//transl alt and :button,:text,:reset's value attribute too when translating text/html
			//callbacks:
			start: function(){},//this (called on start)
			error: function(){},//google's results.error (an error stops the script completely)
			each: function(){},//i, element, translation, source, from, to, opt, number of calls
			complete: function(){},//this, processed this, arr<transl>, arr<orig>, from, to, opt, number of calls
			onTimeout: function(){},//!!! won't abort requests
			timeout: 0//timeout in ms
		}

		opt=$.extend(options, $.fn.translate.defaults, opt)
		//---------------------------------------

		if(opt.rebind===true && opt.replace===true){ $.isFunction($.event.copy) ? '' : $.translate.w("You have to include the copyEvents plugin to enable rebinding events on all elements: http://plugins.jquery.com/project/copyEvents"); }
		opt.start(this);
		var p={};//stores internal parameters
		p.txtorig=[];
		opt.timeout>0 ? p.timeout=setTimeout(function(){opt.onTimeout();}, opt.timeout) : '';
		var jq=this;
		if(opt.walk===true){
			jq=jq.add($(jq).find('*').not('script, '+opt.not))//add all contents to jq
			
			if(opt.not.length){//filter out childnodes if has any:
				var omit=$(opt.not).get(0).firstChild
					while(omit){
						if(omit.nodeType==1){
							hasChildNode=true;
							break;
						}
						omit=omit.nextSibling;
					}
				if(hasChildNode){ jq=jq.not($(opt.not).find('*')) }
			}
		}
		var jql=jq.length
		
		//each:
		for (n=0; n<jql; n++){
			var trtext=''; var hasTextNode=false; var hasChildNode=false;
			var el=jq[n];//current dom element
			if(!el){ continue; }
			var e=$(el);
			
			//------------determine text to extract-------------
			if(opt.subject.constructor==String){	
				trtext=e.attr(opt.subject) || '';
			}else{
				if(opt.altAndVal && (el.tagName.toLowerCase()=='img' || el.tagName.toLowerCase()=='input')){
					if(el.tagName.toLowerCase()=='img'){
						trtext=e.attr('alt') || '';
					}else{
						var type=e.attr('type') || ''; type=type.toLowerCase();
						if(type=='text' || type=='button' || type=='submit'){ trtext=e.val() || ''; }
					}
				}else{
					var cont=el.firstChild;
					//---check childNodes
						opt.walk===true ? '' : hasChildNode=true;
						
						while(cont){
							if(cont.nodeType==1){
								hasChildNode=true;
								break;
							}
							cont=cont.nextSibling;
						}
					//----------------

					if(!hasChildNode){//if doesn't have any children (not text)
						trtext=e.text();
					}else{
						opt.walk===true ? '' : hasTextNode=true;
						cont=el.firstChild;

						//---check textNodes
						while(cont){
							if(cont.nodeType==3 && cont.nodeValue.match(/\S/)!==null){//textnodes with text
								if(cont.nodeValue.match(/<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)>/)!==null){
									if(cont.nodeValue.match(/(\S+(?=.*<))|(>(?=.*\S+))/)!==null){
										hasTextNode=true;
										break;
									}
								}else{
									hasTextNode=true;
									break;
								}
							}
							cont=cont.nextSibling;
						}
						//---------------
						
						if(hasTextNode){//remove child nodes from jq
							trtext=e.html();
							jq=jq.not(e.find('*'));
						}else{
							trtext='';
						}
					}
				}
			}
			//-------------------------------------------

			if(!trtext){ continue; }
			if(!jqt){ var jqt=[]; } 
			jqt.push(el);
			if(!tc){ var tc=''; } 
			tc=tc+'<div>'+trtext+'</div>';
			p.txtorig.push(trtext)
		}//each end
		
		if(!jqt){return this;}//return this when nothing to translate
		opt.comments===false ? tc.replace(/<![ \r\n\t]*(--([^\-]|[\r\n]|-[^\-])*--[ \r\n\t]*)>/g,'') : '';
		p.jqt=jqt; p.jq=this
		
		
		if(opt.translate!==false){
		translate(tc, from, to, function(i, el, tff, orig, from, to, opt, num){
			e=$(el)
			//--------------set data--------------
			if(opt.data===true){
				if(opt.subject.constructor==String){
					$.data(el,'translation.'+from+'.'+opt.subject, orig) 
					$.data(el,'translation.'+ to +'.'+opt.subject, tff) 
				}else{
					
					if(opt.altAndVal && (el.tagName.toLowerCase()=='img' || el.tagName.toLowerCase()=='input')){
						if(el.tagName.toLowerCase()=='img'){
							$.data(el,'translation.'+from+'.'+'alt', orig) 
							$.data(el,'translation.'+ to +'.'+'alt', tff) 
						}else{
							var type=e.attr('type') || ''; type=type.toLowerCase();
							if(type=='text' || type=='button' || type=='submit'){
								$.data(el,'translation.'+from+'.'+'value', orig) 
								$.data(el,'translation.'+ to +'.'+'value', tff) 
							}
						}
					}else{
						$.data(el,'translation.'+from+'.'+'html', orig) 
						$.data(el,'translation.'+ to +'.'+'html', tff) 
					}
				}
			}
			
			//------------set html tag--------------
			opt.setLangAttr===true ? e.attr('lang',to) : '';
			opt.setLangAttr.constructor==String ? e.attr(opt.setLangAttr,to) : '';
			
			//---------------replace----------------
			if(opt.replace===true){
				if(opt.subject.constructor==String){
					e.attr(opt.subject, tff)
				}else{
					if(opt.altAndVal && (el.tagName.toLowerCase()=='img' || el.tagName.toLowerCase()=='input')){
						if(el.tagName.toLowerCase()=='img'){
							e.attr('alt', tff)
						}else{
							var type=e.attr('type') || ''; type=type.toLowerCase();
							if(type=='text' || type=='button' || type=='submit'){
								e.val(tff);
							}
						}
					}else{
						if(opt.rebind===true){//rebind event handlers when html was translated
							var k=e.find('*').not('script').clone(true); var kl=k.length;//clone original html
							e.html(tff);//set new html
							var h=e.find('*').not('script');//get new html
							for (m=0; m<kl; m++){//each()
								h.eq(m).copyEvents(k.get(m))
							}
						}else{
							e.html(tff);
						}
					}
				}
			}
			
			//------------each callback------------
			opt.each(i, el, tff, orig, from, to, opt, num);
		}, opt, p)
		}//opt.translate
		
		//return after processing elements:
		if(opt.returnAll===true){ return $(jqt); }else{ return this; } 
		
}



//
//  Translate function
//

$.translate=function(){
	//-------------set parameters------------
	var t=arguments[0]; var from; var to; var opt={}; var a=arguments[1]; var b=arguments[2]; var c=arguments[3];
	if(typeof a=='undefined' || a.constructor==Object){	return  $.translate.w("Destination language is not set");}
	if(!b && !c){from=''; to=a; }
	if(!c && b){
		if(b.constructor==Object){ from=''; to=a; opt=b;
		}else{ from=a; to=b; } }
	if(a.constructor==String && b && c){from=a; to=b; opt=c;}
	//---------------------------------------
	
	var options={
		limit: 500,//google's character limit
		start: function(){},//(called on start)
		error: function(){},//google's results.error (an error stops the script completely)
		each: function(){},//i, translation[i], source[i], from, to, opt, number of calls
		complete: function(){},//translation, source[i], from, to, opt, number of calls
		onTimeout: function(){},//won't abort requests
		timeout: 0//timeout in ms
	}
	opt=$.extend(options, $.translate.defaults, opt)
	
	if(t.constructor==String){ t=[t]; }//a single string is converted to an array
	var p={};
	opt.timeout>0 ? p.timeout=setTimeout(function(){opt.onTimeout();}, opt.timeout) : '';
	p.fn=true;
	p.txtorig=t;
	opt.start();
	
	t='<div>'+t.join('</div><div>')+'</div>';
	translate(t, from, to, null, opt, p);

}




//
//  Language detection function
//

function detect(t,opt,k,len,arr_langCode,arr_lang,arr_result){
	if(k==0){	
		var arr_langCode=[];
		var arr_lang=[];
		var arr_result=[];
	}
		var dttext=t[k].substring(0,opt.limit*1)
		google.language.detect(dttext, function(result){
			if(!result.error){
				var language = 'unknown';
				for (l in google.language.Languages){
					if (google.language.Languages[l] == result.language){language = l; break;}
				}
				opt.each(k, result.language, language, result)//each callback
					
				arr_langCode.push(result.language);
				arr_lang.push(language);
				arr_result.push(result);
					
				if(k==len-1){
					return opt.complete(arr_langCode, arr_lang,  arr_result);
				}else{
					k++;
					return detect(t,opt,k,len,arr_langCode,arr_lang,arr_result);
				}
					
			}else{
				return opt.error(result.error);
			}
		});
}

$.language=function(t, opt){
	var options={
		start: function(){},
		each: function(){},//i, langCode, lang, result
		complete: function(){},//arrays: langCode, lang, result
		error: function(){},//result.error
			//result: http://code.google.com/apis/ajaxlanguage/documentation/reference.html#detectResult
		limit: 500
	}
	opt=$.extend(options, $.language.defaults, opt)

	if(t.constructor==String){ t=[t]; }//a single string is converted to an array
	opt.start();

	detect(t,opt,0,t.length);
}



//
//  Language detection method
//

$.fn.language=function(opt){
	//this is not recursive like translate: each element's .text() or attribute will be processed
	var options={
		start: function(){},
		each: function(){},//i, e, langCode, lang, result
		complete: function(){},//arrays: e, langCode, lang, result
		error: function(){},//result.error
			//result: http://code.google.com/apis/ajaxlanguage/documentation/reference.html#detectResult
		setLangAttr: true,//true: lang attr; string: this attr will be set; false: don't set any attr
		subject: true,//true: each element's text(); a string: that specific attr's value
		limit: 500
	}
	opt=$.extend(options, $.fn.language.defaults, opt)
	
	opt.start(this);
	var len=this.length;
	var subject;
	
	var arr_e=[];
	var arr_langCode=[];
	var arr_lang=[];
	var arr_result=[];
	
	if(!opt.subject){ return; }
	opt.subject===true ? subject=$(this).text() : '';
	opt.subject.constructor==String ? subject=$(this).attr(opt.subject) : '';
	
	return this.each(function(i, e){
		var dttext=subject.substring(0,opt.limit*1)
		google.language.detect(dttext, function(result){
			if(!result.error){
				var language = 'unknown';
				for (l in google.language.Languages){
					if (google.language.Languages[l] == result.language){language = l; break;}
				}
				
				opt.setLangAttr===true ? $(e).attr('lang', result.language) : '';
				opt.setLangAttr.constructor==String ? $(e).attr(opt.setLangAttr, result.language) : '';

				opt.each(i, e, result.language, language, result)//each callback
				
				arr_e.push(e);
				arr_langCode.push(result.language);
				arr_lang.push(language);
				arr_result.push(result);
					
				if(i==len-1){ opt.complete(arr_e, arr_langCode, arr_lang,  arr_result) }
					
			}else{
				opt.error(result.error);
			}
		});
	})
}


//
//  Init methods
//

$.translate.langLoaded=function(){
}
$.translate.loadLang=function(){
	google.load("language", "1", {"callback" : $.translate.langLoaded});
}
$.translate.initLoader=function(key){
	if(typeof google!='undefined' && google.language.translate){return}
	key ? key='key='+key : key='';
	var script = document.createElement("script");
	script.src = "http://www.google.com/jsapi?"+key+"&callback=$.translate.loadLang";
	script.type = "text/javascript";
	document.getElementsByTagName("head")[0].appendChild(script);
}
$.translate.w=function(m){ if(typeof console!='undefined'){  console.warn(m) } }

$.translate.initLoader()


})(jQuery);